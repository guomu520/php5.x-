# PHP gc机制

##首先我们要了解下php变量结构 zval  zval 的 zval_struct 结构体里有两个字段  refcount__gc、is_ref__gc 这两个字段分别表示 变量值被多少变量名所指向、地址是否被引用。 下面我们具体举例说明
### 1、变量复制
      $a='abcde';
      $b=$a;
      上述代码表示b的值等于a的值，php底层实现并不是复制出一块内存空间来，而是会 把refcount__gc的值+1 b取值的时候会直接来拿之前a的zval
###2、变量销毁
      $a='advde';
      unset($a);
      上述代码内存会被销毁
      
      $a='abcde';
      $b=$a;
      unset($a);
      上述代码呢？ 那如果我销毁了 是不是 $b的值也被销毁了呢？ 所以不会销毁 unset的时候会判断refcount__gc 如果有被其它变量使用则不会被销毁
    
      $a =1;
      $b = $a;
      $b += 5;
      从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？
      答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。
###3、变量&     
      $a =1;
      $b =&$a;
      $b += 5;
      作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！
      但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref__gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount__gc等于1，is_ref__gc等于0;。 当第二条语句执行后($b = &$a;)，refcount__gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！
      最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制.
      这一次，尽管它的refcount等于2，
      
      $a = 1;
      $b = $a;
      $c = &$a;
      再看如下代码呢？自己脑洞吧！！！！！！！
      

